! transform_curvi_xy.jnl
! 
! 18-Apr-2007 extracted from LAS_transforms.jnl
! Set up for curvilinear XY data: curvilinear-to-rectilinear regridding
! or native curvilinear xy plots or sample from curvilinear coordinates.

DEFINE SYMBOL which_var ($num)

IF `($constraint_0_lhs"0|Curv_to_Rect_Regridding>1|*>0")` THEN 
   DEFINE SYMBOL data_var_transform = , Regridded Curvilinear to Rectilinear ($constraint_0_rhs)-degree Grid,
      DEFINE SYMBOL data_dup_varname ($data_var)_regrid

ELIF  `STRINDEX("($ferret_view)", "xy") EQ 0` THEN
   IF ($ferret_interpolate_data%0|false>0|true>1|1|0|*>1%) THEN 
      DEFINE SYMBOL data_var_transform = , Interpolated from Curvilinear coordinates
      DEFINE SYMBOL data_dup_varname ($data_var)_sample
   ENDIF

ELSE
   IF ($ferret_interpolate_data%0|false>0|true>1|1|0|*>1%) THEN \
      DEFINE SYMBOL data_var_transform = , Interpolated from Curvilinear coordinates
ENDIF

! Check the regions in x and y. The Sampling schemes work best if they
! dont have to do moduloing; reset x regions to try to match the longitude
! coordinate variable, and call the initialize_region script again.

! For large datasets, we might pre-set these in the initialization script. 
! Compute them only if undefined

IF `($ferret_curv_lon_min"1|*>0")` THEN \
   DEFINE SYMBOL ferret_curv_lon_min = `($ferret_curvi_coord_lon)[d=($data_num),x=@min,y=@min]`
IF `($ferret_curv_lon_max"1|*>0")` THEN \
   DEFINE SYMBOL ferret_curv_lon_max = `($ferret_curvi_coord_lon)[d=($data_num),x=@max,y=@max]`

! e.g. tripolar grid where the range is 0 to 426 messes up the calculations...

IF `($ferret_curv_lon_max)- ($ferret_curv_lon_min) GT 360` THEN DEFINE SYMBOL ferret_curv_lon_max `($ferret_curv_lon_min) + 360`

IF `($region_x_lo) LT ($ferret_curv_lon_min)` THEN 
   DEFINE SYMBOL region_0_x_lo `($region_0_x_lo) + 360`
   DEFINE SYMBOL region_0_x_hi `($region_0_x_hi) + 360`
   GO LAS_initialize_region 0
ENDIF
IF `($region_x_hi) GT ($ferret_curv_lon_max)` THEN 
   DEFINE SYMBOL region_0_x_lo `($region_0_x_lo) - 360`
   DEFINE SYMBOL region_0_x_hi `($region_0_x_hi) - 360`

   GO LAS_initialize_region 0

   IF `($region_x_lo) LT ($ferret_curv_lon_min)` THEN  ! still crosses branch cut
      DEFINE SYMBOL two_slices 1  ! will need to use all xcoords (get_curv_coord_box)
   ENDIF
ENDIF

! curvilinear to rectilinear regridding

IF `($constraint_0_lhs"0|Curv_to_Rect_Regridding>1|*>0")` THEN
   IF ($region_t"0|*>1") THEN DEFINE SYMBOL reg_zt ($region_t)
   IF ($region_z"0|*>1") THEN DEFINE SYMBOL reg_zt ($region_z)
   IF ($region_zt"0|*>1") THEN DEFINE SYMBOL reg_zt ($region_zt)
   GO transform_curv_to_rect.jnl

ELSE


!!!!!!!!!!!

! Special setup, if a latitude has been specified such that the grid
! is linear south of ($ferret_linear_lat_max)

! Here we check whether the region is within the part of the grid that is rectilinear.
! If it is, then redefine the axes and proceed as if it is a rectilinear grid. Otherwise
! call LAS_set_strides_curvilinear.jnl

! If this is a vector plot, do this only once, on the first vector component
IF ` ($operation_ID"0|Plot_vector>1|*>0") AND ($num) GT 0` THEN EXIT/SCRIPT

IF `($ferret_linear_lat_max"0")` THEN
IF `($ferret_linear_lat_max"0") AND (($region_y_hi"0")  LT ($ferret_linear_lat_max))` THEN 

   ! All numbers in the following comments are for the HYCOM dataset before
   ! any native striding that has been done by LAS_set_strides_curvilinear.jnl
   ! Given as an example only.
   !
   ! The global hycom grid is linear in y< 47 degrees; which corresponds to 
   ! j <= 2172.  
   ! The script sets these constants, ($ferret_linear_lat_max) and if known
   ! ($ferret_linear_lat_indx) = 2172. If index is not known, compute it below.
   !
   ! Define a new y axis with the latitudes from the hycom grid for y <= 47 and 
   ! any meaningless numbers above that.
   !
   ! Define a new x axis with longitudes taken from anywhere below j=2172
   !
   ! When the operation is in a region below y=47 we can just REDEFINE THE AXES
   ! and carry on as if its not a curvilienar grid.
   
   LET ny = `($data_var),return=jsize`
   LET nx = `($data_var),return=isize`
   ! The above are incorrect if axes were strided (!)

   LET xx = x[gx=($data_var)]
   LET yy = y[gy=($data_var)]
   LET nx = `xx,return=isize`
   LET ny = `yy,return=jsize`
   
   ! Find where latitude crosses 47 degrees, if not given and if the y axis
   ! is not strided by a previous call to LAS_set_strides_curvilinear.jnl
   
   ! Kludge allows us to work with subsets of this data.
   IF ($ferret_linear_lat_indx"0|*>1") THEN 
      IF `ny LT ($ferret_linear_lat_indx)` THEN CANCEL SYMBOL ferret_linear_lat_indx
   ENDIF

   IF `($ferret_linear_lat_indx"0|*>1") AND ( ($ystride"0") EQ 0 )` THEN
      LET jloc = ($ferret_linear_lat_indx)
   ELSE
      LET jloc = 0
   
      cancel mode verify
      LET int1 = `INT(ny/10)`
      REPEAT/RANGE=1:`ny`:`int1`/NAME=n (\
      LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
      IF `($ferret_linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
      IF `jloc NE 0` THEN EXIT/LOOP)
   
      LET jloc_1 = `jloc`
      LET jloc = 0
      REPEAT/RANGE=`jloc_1-50`:`jloc_1+50`:5/NAME=n (\
         LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
         IF `($ferret_linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
         IF `jloc NE 0` THEN EXIT/LOOP)
   
      LET jloc_1 = `jloc`
      LET jloc = 0
      REPEAT/RANGE=`jloc_1-5`:`jloc_1+5`:1/NAME=n (\
         LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
         IF `($ferret_linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
         IF `jloc NE 0` THEN EXIT/LOOP)
      set mode/last verify
   ENDIF
   
   ! Define a new y axis.
   
   ! A variable containing the longitudes up to J=`jloc`
   LET mask1 = IF J[GY=latitude] LE `jloc` THEN latitude[i=`INT(nx/2)`] ELSE 0
   
   ! Create a list of the correct total length (3298) and with values larger than
   ! the `jloc`th value above.
   
   DEFINE AXIS/NPOINTS=`ny`/Y=-86:90/UNITS="`latitude[d=1],RETURN=units`" lin_north
   
   LET const = mask1[j=`jloc`]  - Y[GY=lin_north,j=`jloc`] ! to make the axis monotonic
   LET mask2 = IF J[GY=lin_north] GT `jloc` THEN Y[GY=lin_north] + `const` ELSE 0
   
   !! Define new axes and a variable with the old data assinged to these, e.g.
   ! DEFINE AXIS/Y/UNITS="`latitude[D=1],RETURN=units`" merged_y =  YSEQUENCE(mask1) + YSEQUENCE(mask2)
   ! DEFINE AXIS/X/UNITS="`longitude,RETURN=units`" lin_east = longitude[j=`INT(ny/2)`]
   ! LET temp_lin = ($data_var)[GX=lin_east@asn,GY=merged_y@asn]
   
   ! Or even faster if we are just in this region anyway, redefine the input axes.
   
   LET new_y_coordinates = YSEQUENCE(mask1) + YSEQUENCE(mask2)
   DEFINE AXIS/Y/UNITS="`($ferret_curvi_coord_lat)[d=1],RETURN=units`" '`($ferret_curvi_coord_lat),RETURN=yaxis`' = new_y_coordinates
   DEFINE AXIS/X/MODULO/UNITS="`($ferret_curvi_coord_lon),RETURN=units`" '`($ferret_curvi_coord_lat),RETURN=xaxis`' = ($ferret_curvi_coord_lon)[J=`INT(ny/4)`]

   ! Now we no longer need to deal with this data as being on a curvilinear grid
   CANCEL SYMBOL ferret_curvi_coord_lon
   CANCEL SYMBOL ferret_curvi_coord_lat
   CANCEL SYMBOL DEFINE SYMBOL do_curvi_xy = 0
   CANCEL SYMBOL do_curvi_xy_and_hybrid_z = 0
   
   ! Because we have redefined the axes we cant set native strides
   DEFINE SYMBOL no_native_strides_xy = 1
ENDIF

ELSE

   GO LAS_set_strides_curvilinear.jnl

ENDIF

!!!!!!!!!!!

IF `($ferret_curvi_coord_lon"0|*>1") EQ 0` THEN EXIT/SCRIPT


! Set up native curvilinear plots
   LET/TITLE="Longitude"/units=degrees xcoord = ($ferret_curvi_coord_lon)[d=($data_num)]
   LET/TITLE="Latitude"/units=degrees  ycoord = ($ferret_curvi_coord_lat)[d=($data_num)]

!   Native plot in XY

   IF ($ferret_view"|xy>1|*>0") THEN

     IF `($constraint_0_lhs"1|Curv_to_Rect_Regridding>0|*>1")` THEN  ! Do this setup if NOT curv-to-rect regridding
        DEFINE SYMBOL native_curvilinear_xy = 1

        ! Get the range of I,J needed to grab the region. Use it to define the plot or output variable.
        GO get_curv_coord_bbox

        ! Remove this  and uncomment the above to set index range by region
!c        DEFINE SYMBOl clon_imin = 1
!c        DEFINE SYMBOl clon_imax = `($ferret_curvi_coord_lon)[d=($data_num),j=1,x=@ngd]`
!c        DEFINE SYMBOl clat_jmin = 1
!c        DEFINE SYMBOl clat_jmax = `($ferret_curvi_coord_lon)[d=($data_num),i=1,y=@ngd]`
        
        LET/TITLE="Longitude"/units=degrees xcoord = \
          ($ferret_curvi_coord_lon)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax)]
        LET/TITLE="Latitude"/units=degrees  ycoord = \ 
          ($ferret_curvi_coord_lat)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax)]

        LET/d=($data_num) plot_var = ($data_var)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax)]
        IF ($region_zt"0|*>1") THEN LET/d=($data_num) plot_var = \
        ($data_var)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax),($region_zt)]

        DEFINE SYMBOL ferret_plot_base_var = \ ($data_var)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax)]
        IF ($region_zt"0|*>1") THEN DEFINE SYMBOL ferret_plot_base_var = \
        ($data_var)[d=($data_num),i=($clon_imin):($clon_imax),j=($clat_jmin):($clat_jmax),($region_zt)]

        DEFINE SYMBOL ferret_plot_base_var_($which_var) ($ferret_plot_base_var)

        DEFINE SYMBOL ferret_plot_var ($expr1)plot_var($expr2), xcoord, ycoord
        IF ($region_zt"0|*>1") THEN DEFINE SYMBOL ferret_plot_var ($expr1)plot_var($expr2), xcoord, ycoord
        DEFINE SYMBOL ferret_plot_title "($expr1)($data_title)($expr2) ($data_units) Native Curvilinear Plot"

        IF ($expr3"0|*>1") THEN
           DEFINE SYMBOL ferret_plot_var ($expr1)plot_var($expr3)plot_var($expr4), xcoord, ycoord
           IF ($region_zt"0|*>1") THEN DEFINE SYMBOL ferret_plot_var \
             ($expr1)plot_var($expr3)plot_var($expr4), xcoord, ycoord
           DEFINE SYMBOL ferret_plot_title "($expr1)($data_title)($expr3)($data_title)($expr4) ($data_units) Native Curvilinear Plot"
        ENDIF

! If not striding for region, then always use these, and comment out the commands just below.
        IF ($region_x_lo"0|*>1") THEN DEFINE SYMBOL ferret_curvi_quals \   
          ($ferret_curvi_quals)/HLIM=($region_x_lo):($region_x_hi)
        IF ($region_y_lo"0|*>1") THEN DEFINE SYMBOL ferret_curvi_quals \   
          ($ferret_curvi_quals)/VLIM=($region_y_lo):($region_y_hi)

!cc        IF ($region_z"0|*>1") THEN DEFINE SYMBOL ferret_curvi_quals  \   
!cc          ($ferret_curvi_quals)/($region_z)
!cc        IF ($region_t"0|*>1") THEN DEFINE SYMBOL ferret_curvi_quals  \   
!cc          ($ferret_curvi_quals)/($region_t)
        CANCEL SYMBOL ferret_use_graticule

        IF ($ferret_lon_modulo"1|1|0|yes>1|no>0|*>0") THEN 
           IF ($region_x_lo"0|*>1") THEN DEFINE SYMBOL ferret_curvi_quals \   
             ($ferret_curvi_quals)/HLIM=($region_x_lo):($region_x_hi)
! A bug in FILL/MODULO for curvilinear data makes the plot fail for some data
!        IF ($ferret_lon_modulo"1|1|0|yes>1|no>0|*>0") THEN 
!           DEFINE SYMBOL ferret_curvi_quals ($ferret_curvi_quals)/MODULO
        ENDIF

     ENDIF  ! setup for NOT curv-to-rect regridding

! Or set up for native slices: Sample in the X and Y directions of the slice

   ELIF `STRLEN ("($ferret_view)") LE 2` THEN

     IF ($ferret_interpolate_data%0|false>0|true>1|1|0|*>1%) THEN 
        GO curvi_sample_slice.jnl
        DEFINE SYMBOL data_var_transform = , Interpolated from Curvilinear coordinates
     ELSE
        GO curvi_nrst_slice.jnl
     ENDIF

   ENDIF

ENDIF  ! native curvilinear plots or slices.

! End of $RCSfile ------------transform_curvi_xy.jnl-------------------------------

