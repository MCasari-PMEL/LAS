! Special version of get_curv_coord_bbox.jnl with kludge to
! speed up finding the bounding-box.

! get_curv_coord_bbox.jnl

! get the I,J range from curvilinear coordinate variables for
! the requested output rectangle defined by 
!    ($region_x_lo):($region_x_hi)
!    ($region_y_lo):($region_y_hi)
!
! The output is returned as symbols 

! clon_imin
! clon_imax
! clat_jmin
! clat_jmax

! If this has already been called, we are done.
IF ($curv_coord_bbox_done"0") THEN EXIT/SCRIPT
DEFINE SYMBOL curv_coord_bbox_done = 1

! If the whole grid is specified, we are done.

LET xlodiff =  ABS(($curv_lon_min) - ($region_x_lo) )
LET xhidiff =  ABS(($curv_lon_max) - ($region_x_hi) )
IF `ABS((xlodiff) -  (xhidiff)) LT 0.2` THEN
   LET clon_imin = 1
   LET xx = x[gx=($ferret_curvi_coord_lon)]
   STAT xx
   LET clon_imax = ($STAT_NGOOD)

   LET clat_jmin = 1
   LET yy = y[gy=($ferret_curvi_coord_lon)]
   STAT yy
   LET clat_jmax = ($STAT_NGOOD)

   DEFINE SYMBOL clon_imin `clon_imin`
   DEFINE SYMBOL clon_imax `clon_imax`
   DEFINE SYMBOL clat_jmin `clat_jmin`
   DEFINE  SYMBOL clat_jmax `clat_jmax`

   EXIT/SCRIPT
   
ENDIF

LET kludge = 1

IF `kludge LT 1` THEN
   LET  box_longitude = ($ferret_curvi_coord_lon)[d=($data_num)]
   LET  box_latitude = ($ferret_curvi_coord_lat)[d=($data_num)]

ELSE
! TODO: VERY KLUDGY way of getting a subset of the data to do this on, 
! otherwise its very slow...
!
   LET nx = `($ferret_curvi_coord_lon)[d=($data_num),j=1,x=@ngd]`
   LET ny = `($ferret_curvi_coord_lon)[d=($data_num),i=1,y=@ngd]`

   LET ns = 50
   LET dx = MAX(1,`INT(nx/ns)`)
   LET dy = MAX(1,`INT(ny/ns)`)
   LET  box_longitude = ($ferret_curvi_coord_lon)[d=($data_num),i=1:`nx`:`dx`,j=1:`ny`:`dy`]
   LET  box_latitude = ($ferret_curvi_coord_lat)[d=($data_num),i=1:`nx`:`dx`,j=1:`ny`:`dy`]
ENDIF

! See if this is a rectangle or an X line; if an X line then expand
! the region to make a rectangle.

IF `($region_x_hi) GT ($region_x_lo)` THEN
   LET box_x_lo = ($region_x_lo)
   LET box_x_hi = ($region_x_hi) 
ELSE
   LET box_x_lo = `($region_x_lo) - 4.`
   LET box_x_hi = `($region_x_hi) + 4.`
ENDIF

! See if this is a rectangle or a Y line; if a Y line then expand
! the region to make a rectangle.

IF `($region_y_hi) GT ($region_y_lo)` THEN
   LET box_y_lo = ($region_y_lo)
   LET box_y_hi = ($region_y_hi) 
ELSE
   LET box_y_lo = `($region_y_lo) - 4.`
   LET box_y_hi = `($region_y_hi) + 4.`
ENDIF

! Define a small output grid, 2x2 and use the curvilinear map function

! The variable map includes the indices within the source 
! grid which correspond to coordinates in the destination grid.
! These are the lower lon and lat and upper lon and lat indices:

DEFINE AXIS/X=`box_x_lo`:`box_x_hi`/NPOINTS=2/MODULO/UNITS=degrees xaxbox
DEFINE AXIS/Y=`box_y_lo`:`box_y_hi`/NPOINTS=2/UNITS=degrees yaxbox
 
!  Define a variable on the output grid

LET lonlatbox = Y[GY=yaxbox] + X[GX=xaxbox]
 
! Compute weights for the mapping
 
LET mapbox = curv_to_rect_map (box_longitude, box_latitude, lonlatbox, 10)

! e.g. here are the longitude indices (L=2) and latitude indices (L=3)
! the four nearest neighbors (K=1:4) in the curvilinear grid, which map
! to the i=1,j=1 location on the output axes.

LOAD mapbox
LIST/I=1/J=1/L=2:3 mapbox

DEFINE SYMBOL clon_imin `mapbox[i=1,j=@min,l=2,k=@min]`
DEFINE SYMBOL clon_imax `mapbox[i=2,j=@max,l=2,k=@max]`
DEFINE SYMBOL clat_jmin `mapbox[i=@min,j=1,l=3,k=@min]`
DEFINE SYMBOL clat_jmax `mapbox[i=@max,j=2,l=3,k=@max]`

! Restore striding done above, via DX,DY; making sure indices 
! dont go outside data range.
IF `KLUDGE GE 1` THEN
   DEFINE SYMBOL clon_imin `MAX(1,dx*mapbox[i=1,j=@min,l=2,k=@min]-dx)`
   DEFINE SYMBOL clon_imax `MIN(nx,dx*mapbox[i=2,j=@max,l=2,k=@max]+dx)`
   DEFINE SYMBOL clat_jmin `MAX(1,dy*mapbox[i=@min,j=1,l=3,k=@min]-dy)`
   DEFINE SYMBOL clat_jmax `MIN(ny,dy*mapbox[i=@max,j=2,l=3,k=@max]+dy)`
ENDIF

! If the region extends over the branch cut, return the whole 
! range of longitude indices

IF `($clon_imin) GT ($clon_imax)` THEN
   DEFINE SYMBOL clon_imin 1
   DEFINE SYMBOL clon_imax `box_longitude,RETURN=isize`
ENDIF

