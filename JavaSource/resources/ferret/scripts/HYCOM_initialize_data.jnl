!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! HYCOM_initialize_data.jnl
! $Revision:$
! 
! $Author:$
! $Date:$
 

! Define the plot variable. For comparison plots, we want to save the dataset number
! for each dataset.

DEFINE SYMBOL data_num = `($data_var),return=dsetnum`
DEFINE SYMBOL data_($num)_num = `($data_var),return=dsetnum`

DEFINE SYMBOL ferret_plot_var = ($data_var)[d=($data_num),($region_full)]

! BEGIN HYCOM initialization section ------------

! NOTE:  For Hybrid Z datasets we must open the 'layer thickness' data and
! NOTE:  create ferret_plot_var by using ZAXREPLACE_ZLEV.  The exception is
! NOTE:  when we're doing section plots -- then the user may choose to do a
! NOTE:  3-arg plot to see the native coordinates.

! Interface gives a choice of native Z coordinates only for XZ, YZ (or ZT?) 
! views otherwise use hybrid Z regridding.

DEFINE SYMBOL native_Z_plot = 0
IF ($constraint_0_lhs"0|Native_Z_section>1|*>0") THEN \
  DEFINE SYMBOL native_Z_plot ($constraint_0_rhs"0|yes>1|no>0|*>0")

IF ($ferret_thk_url"0|*>1") THEN
   SET DATA "($ferret_thk_url)"

   DEFINE SYMBOL thk_num = `($ferret_thk_var),return=dsetnum`

   IF ($error_status"0|*>1") THEN
     MESSAGE/ERROR "**ERROR Layer Thickness dataset not opened"
     EXIT/PROGRAM
   ENDIF
ENDIF

SET DATA ($data_num)  ! for convenience, default dataset has the data variable.

! Pre-set these so the script doesnt have to take the time to do this...
! If the data had valid_range for the curvilinear coords we could use that.

DEFINE SYMBOL curv_lon_min = 74.12
DEFINE SYMBOL curv_lon_max = 434.12

DEFINE SYMBOL linear_lat_max = 47.0  ! for < 47 degrees, the grid is rectilinear
DEFINE SYMBOL linear_lat_indx = 2172 ! for j < 2172, the grid is rectilinear. If this 
                                     ! is not known the script will compute it.

SET MEMORY/SIZ=80

IF ($native_Z_plot"0") THEN DEFINE SYMBOL native_Z_plot ($ferret_view"|xz>1|yz>1|zt>1|*>0")
! IF ($native_Z_plot"0") THEN DEFINE SYMBOL native_Z_plot ($ferret_view"|xz>1|yz>1|*>0")

! NOTE:  Hardcoded depths appropriate only for HYCOM!
IF ($ferret_thk_url"0|*>1") THEN \
DEFINE axis/z/depth/units=`($ferret_thk_var)[d=($thk_num)],return=units`/bounds fixed_z_axis = \ 
     {0.,2., 5, 10.,20.,30.,50.,75.,100.,150.,200.,300.,400.,600.,800.,1000.,1200.,1500.,2000.,3000.,4000.,6000.,8000.},\
     {0.,1.,3.5,7.5,15.,25.,40.,62., 88.,125.,175.,250.,350.,500.,700., 900.,1100.,1350.,1750.,2500.,3500.,5000.,7000.,8000.}

! END Hybrid Z initialization section --------------

! From the region and the grid we can define striding. 
! Eventually this might be done in a general way, in LAS_initialize_dataset.
!  Do this only for the HYCOM high resolution data, so put it in  HYCOM_init script

! Here we check whether the region is within the part of the grid that is rectilinear.
! If it is, then redefine the axes and proceed as if it is a rectilinear grid. Otherwise
! call LAS_set_strides_curvilinear.jnl

! If this is a vector plot, do this only once, on the first vector component
IF ` ($operation_ID"0|Plot_vector>1|*>0") AND ($num) GT 0` THEN EXIT/SCRIPT

IF `($linear_lat_max"0") AND (($region_y_hi"0")  LT ($linear_lat_max))` THEN 

   ! All numbers in the following comments are for the dataset before
   ! any native striding that has been done by LAS_set_strides_curvilinear.jnl
   !
   ! The global hycom grid is linear in y< 47 degrees; which corresponds to 
   ! j <= 2172.  
   ! The script sets these constants, ($linear_lat_max) and if known
   ! ($linear_lat_indx) = 2172. If index is not known, compute it below.
   !
   ! Define a new y axis with the latitudes from the hycom grid for y <= 47 and 
   ! any meaningless numbers above that.
   !
   ! Define a new x axis with longitudes taken from anywhere below j=2172
   !
   ! When the operation is in a region below y=47 we can just REDEFINE THE AXES
   ! and carry on as if its not a curvilienar grid.
   
   LET ny = `($data_var),return=jsize`
   LET nx = `($data_var),return=isize`
   ! The above are incorrect if axes were strided (!)

   LET xx = x[gx=($data_var)]
   LET yy = y[gy=($data_var)]
   LET nx = `xx,return=isize`
   LET ny = `yy,return=jsize`
   
   ! Find where latitude crosses 47 degrees, if not given and if the y axis
   ! is not strided by a previous call to LAS_set_strides_curvilinear.jnl
   
   ! Kludge allows us to work with subsets of this data.
   IF ($linear_lat_indx"0|*>1") THEN 
      IF `ny LT ($linear_lat_indx)` THEN CANCEL SYMBOL linear_lat_indx
   ENDIF

   IF `($linear_lat_indx"0|*>1") AND ( ($ystride"0") EQ 0 )` THEN
      LET jloc = ($linear_lat_indx)
   ELSE
      LET jloc = 0
   
      cancel mode verify
      LET int1 = `INT(ny/10)`
      REPEAT/RANGE=1:`ny`:`int1`/NAME=n (\
      LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
      IF `($linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
      IF `jloc NE 0` THEN EXIT/LOOP)
   
      LET jloc_1 = `jloc`
      LET jloc = 0
      REPEAT/RANGE=`jloc_1-50`:`jloc_1+50`:5/NAME=n (\
         LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
         IF `($linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
         IF `jloc NE 0` THEN EXIT/LOOP)
   
      LET jloc_1 = `jloc`
      LET jloc = 0
      REPEAT/RANGE=`jloc_1-5`:`jloc_1+5`:1/NAME=n (\
         LET lat_first = ($ferret_curvi_coord_lat)[d=($data_num),i=`INT(nx/2)`,j=`n`];\
         IF `($linear_lat_max) LT lat_first` THEN LET jloc = `n-1`;\
         IF `jloc NE 0` THEN EXIT/LOOP)
      set mode/last verify
   ENDIF
   
   ! Define a new y axis.
   
   ! A variable containing the longitudes up to J=`jloc`
   LET mask1 = IF J[GY=latitude] LE `jloc` THEN latitude[i=`INT(nx/2)`] ELSE 0
   
   ! Create a list of the correct total length (3298) and with values larger than
   ! the `jloc`th value above.
   
   DEFINE AXIS/NPOINTS=`ny`/Y=-86:90/UNITS="`latitude[d=1],RETURN=units`" lin_north
   
   LET const = mask1[j=`jloc`]  - Y[GY=lin_north,j=`jloc`] ! to make the axis monotonic
   LET mask2 = IF J[GY=lin_north] GT `jloc` THEN Y[GY=lin_north] + `const` ELSE 0
   
   !! Define new axes and a variable with the old data assinged to these, e.g.
   ! DEFINE AXIS/Y/UNITS="`latitude[D=1],RETURN=units`" merged_y =  YSEQUENCE(mask1) + YSEQUENCE(mask2)
   ! DEFINE AXIS/X/UNITS="`longitude,RETURN=units`" lin_east = longitude[j=`INT(ny/2)`]
   ! LET temp_lin = ($data_var)[GX=lin_east@asn,GY=merged_y@asn]
   
   ! Or even faster if we are just in this region anyway, redefine the input axes.
   
   LET new_y_coordinates = YSEQUENCE(mask1) + YSEQUENCE(mask2)
   DEFINE AXIS/Y/UNITS="`($ferret_curvi_coord_lat)[d=1],RETURN=units`" '`($ferret_curvi_coord_lat),RETURN=yaxis`' = new_y_coordinates
   DEFINE AXIS/X/MODULO/UNITS="`($ferret_curvi_coord_lon),RETURN=units`" '`($ferret_curvi_coord_lat),RETURN=xaxis`' = ($ferret_curvi_coord_lon)[J=`INT(ny/4)`]

   ! Now we no longer need to deal with this data as being on a curvilinear grid
   CANCEL SYMBOL ferret_curvi_coord_lon
   CANCEL SYMBOL ferret_curvi_coord_lat
   
   ! Because we have redefined the axes we cant set native strides
   DEFINE SYMBOL no_native_strides_xy = 1

ELSE

   GO LAS_set_strides_curvilinear.jnl

ENDIF

! End of HYCOM_initialize_data.jnl  ------------------------------------------------------

