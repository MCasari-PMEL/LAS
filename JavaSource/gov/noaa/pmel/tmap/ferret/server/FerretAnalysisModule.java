package gov.noaa.pmel.tmap.ferret.server;

import java.io.*;
import java.util.*;
import javax.servlet.http.*;
//import java.net.*;

import org.iges.util.*;
import org.iges.anagram.*;
import org.iges.anagram.filter.*;

/** This module runs a Ferret analysis task and returns a handle to the results.<p> 
 * 
 *  A Ferret analysis task is issued using a URL with "_expr_": 
 *  /dirs/_expr_{<code>datasetNames</code>}{<code>expressions</code>}[{<code>bounds</code>}]<p>
 *
 * This Ferret analysis expression can be seen as a temporary dataset generated by FDS server.
 * A OpenDAP query can be imposed on this temporary dataset, such as DDS, DAS, DODS,
 * INFO or ASCII query.
 *
 * There are 2 or 3 clauses in a Ferret analysis task URL, separated by curly brackets.
 * The first and second clauses are required, but the third clause is optional.
 *
 * The first <code>datasetNames</code> specify those dataset names that will be used to generate the
 * temporary dataset. <code>datasetNames</code> can be local datasets, remote DODS datasets or 
 * another Ferret analysis task sent to the same server. All the specified dataset names 
 * should be comma-separated.<p>
 * 
 * <code>expressions</code> can be any Ferret commands to generate the temporary dataset.
 * The expression should be semi-comma separated. If a variable is defined without using Ferret 
 * commands, the variable will be used as a variable in the resultant dataset.<p>
 *
 * <code>bounds</code> is optional. It specifies the subset requested. It can be expressed
 * in two ways:<p>
 * <ul>
 * <li>If it starts with "i:", then it specifies the subset by indices.<p> 
 * <li>Otherwise, it specifies the subset in the world coordinates.<p>
 * </ul>
 *
 * Class org.iges.grads.server.GradsAnalysisModule is used as a reference when writing this class<p> 
 *
 * @author Yonghua Wei
 */

public class FerretAnalysisModule 
    extends AbstractModule {

    public String getModuleID() {
	return "analyzer";
    }

    public FerretAnalysisModule(FerretTool tool) {
	this.tool = tool;
    }

    public void configure(Setting setting) {
    }

    /** Parses the input String <code>handleName</code> and generate a temporary
     *  dataset using Ferret server.<p> 
     *  The temporary dataset is returned as a {@link TempDataHandle}
     *
     * @param handleName the name of handle for the generated temporary dataset. It should
     *        have at least a substring "_expr_".
     * @param request the <code>HttpServletRequest</code> instance that represents the 
     *        current request 
     * @param privilege the privilege associated with the current request.
     * @return a {@link TempDataHandle} class representing the temporary dataset generated
     *        by the analysis expression
     * @throws ModuleException if anything goes wrong during the analysis
     */

    public TempDataHandle doAnalysis(String handleName, 
				     HttpServletRequest request,
				     Privilege privilege) 
	throws ModuleException {

	info("doAnalysis for "+handleName);
	
	String allowed = privilege.getAttribute("analyze_allowed", "true");
	if (!allowed.equals("true")) {
	    throw new ModuleException(this, 
				      "Analysis service not available");
	}

	ParsedExpression parsed = new ParsedExpression(handleName, privilege);

        String shortName = "/_expr_" + FDSUtils.MD5Encode(handleName);

	File jnlFile = server.getStore().get(this, shortName+".jnl");
	try {
            createJnlFile(parsed, request, jnlFile, privilege);
            StringBuffer varList = new StringBuffer();
            
            Iterator vIt = parsed.variables.iterator();
            if(vIt.hasNext())
                varList.append(""+vIt.next());
            while (vIt.hasNext()) {
                varList.append(","+vIt.next());
	    }

            if( parsed.bounds != null )
               info("parsed.bounds.toString()=" + parsed.bounds.toString());
            info("parsed.expressionString=" + parsed.expressionString);

	    StringBuffer title = new StringBuffer();
	    title.append("  source datasets: ");

   	    Iterator dIt = parsed.dataNames.iterator(); 
	    title.append((String)dIt.next());
	    while(dIt.hasNext()) {
		title.append(" ");
		title.append((String)dIt.next());
	    }

	    title.append("  expression: ");
	    title.append(parsed.expressionString);

	    FerretDataInfo info = 
		new FerretDataInfo( shortName,
                                    jnlFile.getAbsolutePath(),
                                    varList.toString(),
                                    "jnl",
                                    title.toString(),
                                    null,
                                    null,
                                    null,
                                    null);

	    
	    return new FerretTempHandle(handleName,
				        info,
				        new HashSet());

	} catch (ModuleException me) {
            jnlFile.delete();
	    throw me;
	} catch (AnagramException age) {
            jnlFile.delete();
 	    throw new ModuleException(this, age.getMessage());
        } catch (Exception e) {
            jnlFile.delete();
            throw new ModuleException(this, e.getMessage());
	}
        finally {}		    

    }

    /** Creates a temporary journal file for Ferret to run.
     *
     * @param parsed a {@link ParsedExpression} instance for input analysis expression
     * @param request the <code>HttpServletRequest</code> instance that represents the 
     *        current request
     * @param jnlFile the returned jounal file
     * @param privilege the privilige associated with this analysis task
     * @throws ModuleException if something wrong during the jounal file creation
     */
    protected void createJnlFile(ParsedExpression parsed,
                                 HttpServletRequest request,
                                 File jnlFile, 
                                 Privilege privilege) 
        throws ModuleException {

	try {
	    PrintWriter jnlWriter = new PrintWriter
		                           (new BufferedWriter
		                               (new FileWriter
			                            (jnlFile.getAbsolutePath(), false)));
	    String baseURL = "http://" + 
	        request.getServerName() + ":" +
	        request.getServerPort() + 
		request.getContextPath();
	
	    Iterator dIt = parsed.dataNames.iterator();
	    Catalog catalog = server.getCatalog();
	    while (dIt.hasNext()) {
		String name = (String)dIt.next();

                if(!name.startsWith("http://")) {
                    name = baseURL + name;
		}
                name = FDSUtils.encodeURL(name);

                jnlWriter.println("set data \"" + name+"\"");
	    }

            jnlWriter.println("set data 1");

            if(parsed.bounds!=null)
                jnlWriter.println("set region"+parsed.bounds.toString());

            Iterator eIt = parsed.expressions.iterator();
	    while (eIt.hasNext()) {
	        jnlWriter.println(eIt.next());
	    }
 
            jnlWriter.flush();
            jnlWriter.close();
	} 
        catch (IOException ioe) {
            throw new ModuleException(this, ioe.getMessage()); 
	}
        catch (Exception e) {
            throw new ModuleException(this, e.getMessage()); 
	} 
    }

   /** Tests if the current user is allowed to carry out a
    *  analysis expression specified by <code>handleName</code>
    *  
    *  @param handleName the name of handle for the generated temporary dataset. It should
    *       have at least a substring "_expr_".
    *  @param privilege the privilige associated with this analysis task.
    */
    public boolean allowAnalysis(String handleName, 
				 Privilege privilege) 
          throws ModuleException {
          new ParsedExpression(handleName, privilege);
          return true;
    }

    /** The {@link FerretTool} module
     */
    protected FerretTool tool;

    /** Internal class to parse the analysis expression
     *
     * @author Yonghua Wei
     */

    protected class ParsedExpression {

	/** Constructor to generate a <code>ParsedExpression</code> class for an analysis expression.
	 *
         *  @param fullString the analysis expression to be parsed
	 *  @param privilege privilege associated with this request
	 *  @throws ModuleException if the analysis expression is wrong or not allowed
	 */
	protected ParsedExpression(String fullString, 
				      Privilege privilege) 
	    throws ModuleException {

	    this.fullString = fullString;
            this.localPath=fullString.substring(0,fullString.indexOf(AnalysisFilter.ANALYSIS_PREFIX));
            this.ae = fullString.substring(fullString.indexOf(AnalysisFilter.ANALYSIS_PREFIX)
                                           +AnalysisFilter.ANALYSIS_PREFIX.length());

            List clauses;
	    try {  
                FDSUtils.parseFullString(ae);
                clauses = getClauses(ae);
                Iterator cIt = clauses.iterator();
                parseDatasetNames((String)cIt.next(), privilege);
                parseExpressions((String)cIt.next(), privilege);
                if(cIt.hasNext()){
                    parseBounds((String)cIt.next());
		} else {
                    bounds = null;
		}
	    } catch (AnagramException ane) {
		throw new ModuleException(FerretAnalysisModule.this,
					  "invalid expression",
					  ane);
	    }	
	}

        /** Parses the datasetname clause and the parsed dataset names
	 * are put in object member <code>dataNames</code>
	 *
	 * @param datasetNames the comma-separated dataset names
         * @param privilege privilege associated with this request
	 * @throws AnagramException if the syntax of this clause is wrong
	 */
	protected void parseDatasetNames(String datasetNames, Privilege privilege)
	    throws AnagramException {

            int startIndex=0, endIndex=0;	    
	    dataNames = new ArrayList();
            endIndex = FDSUtils.firstIndexOf(',', datasetNames, startIndex);
	    while (endIndex>=0) {
		String name = datasetNames.substring(startIndex, endIndex);
		name = standardizePath(name, localPath);
                if(name.length()>0){
                    if(!privilege.allowsPath(name)) {
                        throw new AnagramException ("The dataset:\'" + name + "\' not allowed, ");
	            }
		   dataNames.add(name);
		}
                startIndex = endIndex + 1;
                endIndex = FDSUtils.firstIndexOf(',', datasetNames, startIndex);
	    }

            String name = datasetNames.substring(startIndex, datasetNames.length());
            name = standardizePath(name, localPath);

            if(name.length()>0){
                if(!privilege.allowsPath(name)) {
                   throw new AnagramException ("The dataset:\'" + name + "\' not allowed ");
	        }
                dataNames.add(name);
	    }
	}

        /** Parses the expression clause and the parsed expressions
	 * are put in object member <code>expressions</code>
	 *
	 * @param exps the semi-comma-separated expressions
         * @param privilege privilege associated with this request
	 * @throws AnagramException if the syntax of this clause is wrong
	 */	
	protected void parseExpressions(String exps, Privilege privilege) 
	    throws AnagramException {

            int startIndex=0, endIndex=0;

	    expressionString = exps;
	    expressions = new ArrayList();
            variables = new ArrayList();
            int i =0;
            try {
                endIndex = FDSUtils.firstIndexOf(';', exps, startIndex);
	        while (endIndex>=0) {
                    i++;
		    String exp = exps.substring(startIndex, endIndex);
                    parseSingleExpression(exp, privilege);
                    startIndex = endIndex + 1;
                    endIndex = FDSUtils.firstIndexOf(';', exps, startIndex);
	        }
                i++;
                String exp =exps.substring(startIndex, exps.length());
                parseSingleExpression(exp, privilege);
	    } catch (AnagramException ae) {
                throw new AnagramException(ae.getMessage()+"in expression (" + i + ")");
	    }
	}

        /** Parses a single expression
	 *
	 * @param exp a single expression
	 * @param privilege the privilege associated with this request
	 * @throws AnagramException if the syntax of this expression is wrong or not allowed
	 */	
        protected void parseSingleExpression(String exp, Privilege privilege) 
            throws AnagramException {
            exp = FDSUtils.compactSpacesFor(exp);
            if(exp.length()>0) {
                if(FDSUtils.isFerretCommand(exp)) {
                    if(!privilege.allowsCommand(exp)) {
                        throw new AnagramException ("The Ferret command:\"" + exp + "\" not allowed, ");
	            }
                    expressions.add(exp);
                } else {
                    int posOfEqSign = FDSUtils.firstIndexOf('=', exp);
                    if(posOfEqSign > 0) {
                         expressions.add("let/d=1 "+exp);
                         variables.add(exp.substring(0, posOfEqSign));
	            } else {
                         variables.add(exp);
	            }
	        }
	    }
	}

        /** Parses the bound specified by <code>boundsString</code>
	 *  If the <code>boundsString</code> starts with "i:", the bound is
	 *  specified by indeces; otherwise it is specified in world coordinates.
	 *
	 * @param boundsString the string to specify the bound
	 * @throws AnagramException if the syntax of bound string is wrong
	 */	
	protected void parseBounds(String boundsString)
	    throws AnagramException {
	    boundsString =
		boundsString.replace(',', ' ').replace(':',' ').replace('+',' ');
            if(debug()) info("boundsString="+boundsString);
	    try {
                if(boundsString.startsWith("i ")) {
		    bounds = new Bounds.Grid(boundsString.substring(2), true);
		} else {
                    bounds = new Bounds.World(boundsString);
		}
	    } catch (IllegalArgumentException iae) {
		throw new AnagramException(iae.getMessage());
	    }
	}


        /** Separates a full expression string into different clauses.
	 *  Clauses in the full expression are separated by pairs of curly brackets.
	 *
	 * @param fullStr the full expression string
	 * @return a list of clauses in String type 
	 * @throws AnagramExcepiton if the syntax of this full expressio is wrong
	 */
        protected List getClauses(String fullStr) 
            throws AnagramException {
            List returnVal = new ArrayList();
            int startIndex=0, endIndex=0;
            int i;
         
            for(i=1;i<=2;i++) {
                startIndex = FDSUtils.firstIndexOf('{', fullStr, endIndex);
                if(startIndex<0 ) {
                     throw new AnagramException("{ for clause " + i + " is expected");
	        }
                endIndex = FDSUtils.firstIndexOf('}', fullStr, startIndex);
                if(endIndex<0 ) {
                     throw new AnagramException("} for clause " + i + " is expected");
	        }
                returnVal.add(fullStr.substring(startIndex+1, endIndex));
	    }

            startIndex = FDSUtils.firstIndexOf('{', fullStr, endIndex);
            if(startIndex>=0) {
                endIndex = FDSUtils.firstIndexOf('}', fullStr, startIndex);
                if(endIndex<0 ) {
                     throw new AnagramException("} for clause 3 is expected");
	        }
                returnVal.add(fullStr.substring(startIndex+1, endIndex));

                startIndex = FDSUtils.firstIndexOf('{', fullStr, endIndex);
                if(startIndex>=0) {
                     throw new AnagramException("There are more than 3 clauses");
		}
	    }

            return returnVal;
	}
   
        /** Gets a standardize a relative path.
         *
         * @param path the path to be standardized, it can be an absolute
         *        path or a relative path.
         * @param localPath the current local directory. useful when path 
         *        is relative path.
         * @return a standardized absolute path in String type.
         * @throws AnagramException if the format of the path is not valid.
         */
        protected String standardizePath(String path, String localPath) 
           throws AnagramException {
           path = FDSUtils.stripSpacesFrom(path);
           if(path.startsWith("http:/")&&!path.startsWith("http://")) {
               path ="http://"+path.substring(6);
           }
           if(!(path.equals("")||path.equals("/")||path.startsWith("http:/"))){
	       if(path.endsWith("/")) {
                   path = path.substring(0, path.length()-1);
	       }
               if(!path.startsWith("/")) {
                   path = localPath+"/"+path;
               }

               StringTokenizer dIt = new StringTokenizer(path, "/");
               LinkedList directories = new LinkedList();

               while(dIt.hasMoreTokens()){
                   String dir = dIt.nextToken();

                   if(dir.equals("..")){
                      directories.removeLast();
                   }
                   else{
                      directories.add(dir);
                   } 
               }

               ListIterator dirIt = directories.listIterator(0); 
               path ="";
               while(dirIt.hasNext()){
                  path = path+"/"+dirIt.next();
               }
 
               if(path.equals(""))
                  path="/";
           }
           
           return path;
        }


        /** The full input string
	 */
	protected String fullString;

        /** The current local directory
         */
        protected String localPath;

        /** The analysis expression
         */
        protected String ae;

	/** The expresion string that contains multiple expressions
         */
      	protected String expressionString;

	/** The list of parsed dataset names
	 */
	protected List dataNames;

	/** The list of parsed expressions
	 */
        protected List expressions;

	/** The list of parsed variables
	 */
        protected List variables;

        /** The parsed bound
	 */
	protected Bounds.Base bounds;

    }

}
